# Every review, remarks and corrections are welcomed  
# and to be sent to l.brieulle(at)gmail(dot)com

from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing

def convert(z, v, normal_basis = None): 
    '''
    The goal of this function is to find the coefficients of an element z 
    of a finite field in the normal basis generated by the normal element v
    in the same finite field.
    
    Find the c_i such as z = sum_i c_i.v^(p^i)
    '''
    n = v.parent().degree()
    p = v.parent().characteristic()
    R = PolynomialRing(GF(p), 'U')
    U = R.gen()

    if normal_basis is None:
        normal_basis = [v]
        for i in range(n-1):
            normal_basis.append(normal_basis[-1]**p)

    # We need only to compute Tr(v*v^(p^(n-i))) since the matrix is circulant.
    B = []
    for i in range(n):              
        B.append((v*normal_basis[-i]).trace())


    inv = R(B).inverse_mod(U**n - 1)    # We compute the inverse of the image of
                                        # the circulant matrix B in the cyclotomic ring 
                                        # GF(p^n)[U]/(U^n - 1) 
    
    val_trz = []   
    for i in range(n):
        val_trz.append((v*(z**p**(n-i))).trace())
    
    # We will now compute the coefficients c_i while keeping in mind that they 
    # are computed from each rows of the matrix B. So we need to take that into 
    # account and push the coefficient of inv "to the right". Practically, we 
    # just need to index them with (j-i)%n.
    c = []
    for i in range(n):                
        c.append(sum(inv[(j-i)%n]*val_trz[j] for j in range(n)))

    
    tuple(c)
    return (c, normal_basis, B, inv)



def isom_normal(v,w, F, G, normal_basis_w = None, normal_basis_v = None):
    '''
    Function that explicitly computes the isomorphism phi such as phi(v) = w.

    So we need that v and w are normal elements of F and G respectively and that
    there exists an isomorphism such as phi(v) = w.

    Concretely, we have the following :

    x = sum_i c_i*v^{p^i} => phi(x) = sum_i c_i*w^{p^i}

    we are computing phi(x).
    '''
    p = F.characteristic()
    n = F.degree()

    # We need to compute the normal basis generated by w.
    if normal_basis_w is None:
        normal_basis_w = [w]
        for i in range(n):
            normal_basis_w.append(normal_basis_w[-1]**p)

    # We begin by computing the coefficients of x in the normal basis
    # generated by v.
    normal_coefficients = convert(F.gen(), v, normal_basis_v)[0] 

    # Then we simply return its image in respect of the normal basis 
    # generated by w.
    return sum(normal_coefficients[i]*normal_basis_w[i]
                for i in range(n))


def calcul_isom_normal(elem, F, G, img_x):
    '''
    Function that given an element of F computes its image in G by the 
    isomorphism defined by the image of F.gen() named img_x.
    '''

    n = F.degree()

    elem_vector = elem.vector()

    puis_img = [1]

    for i in range(n):
            puis_img.append(puis_img[-1]*img_x)

    return sum([elem_vector[i]*puis_img[i] for i in range(n)])

