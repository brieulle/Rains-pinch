# Every review, remarks and corrections are welcomed  
# and to be sent to l.brieulle(at)gmail(dot)com

from sage.rings.polynomial.polynomial_ring_constructor import PolynomialRing

def convert(z, v, normal_basis = None): 
    '''
    INPUT :
     
    - ``z`` -- an element of a finite field.

    - ``v`` -- a normal element of a finite field.

    - ``normal_basis`` -- (default : None) a pre-calculated normal basis of v.

    OUTPUT :

    - ``c`` -- a tuple containing the coefficients of z in the normal basis
      generated by v.

    EXAMPLES : 
    
    sage: R.<X> = PolynomialRing(GF(101))

    sage: f = X^19 + 84*X^18 + 72*X^17 + 38*X^16 + 36*X^15 + 21*X^14 + X^13 +
    72*X^12 + 44*X^11 + 14*X^10 + 42*X^9 + 7*X^8 + 32*X^7 + 55*X^6 + 68*X^5 +
    40*X^4 + 61*X^3 + 99*X^2 + 76*X + 4

    sage: k.<x> = GF(101**19, name = 'x', modulus = f)

    sage: v = 22*x^18 + 72*x^17 + 25*x^16 + 22*x^15 + 43*x^14 + 55*x^13 +
    69*x^12 + 100*x^11 + 2*x^10 + 30*x^9 + 96*x^8 + 97*x^7 + 23*x^6 + 83*x^5 +
    51*x^4 + 70*x^3 + 70*x^2 + 67*x + 68

    sage: convert(x, v)
    [68, 5, 22, 31, 49, 70, 13, 93, 82, 43, 70, 27, 22, 17, 90, 91, 81, 59, 38]


    ALGORITHM :

    The goal is to get the coefficient of an element z of a finite field in the
    normal base generated by a normal element v of the same finite field.

    The algorithm makes use of an isomorphisme between the ring of the circulant
    matrix of size n on GF(q) and the quotient ring GF(q)[u]/(u**n - 1). The
    result is that instead of inverting a matrix, we'll just have to invert an
    element of a quotient ring (which should require less ressources).

    Say you have an element z and normal v, then there's exist c_i in GF(q) such
    that :

    z = \sum_{0 <= i < n}{c_i*v^(p^i)}

    The goal is to find those c_i. After some calculation making use of the
    property of the Frobenius (morsphism and generates the Galois group), we end
    up with the following formula :

    L(z^(p^(n-j))) = \sum_{0 <= i < n}{c_i*L(v^(p^(i + n - j)))}

    where L is some linear form/function; it will be the trace with a particular
    for. The matrix :

    (b_ij) = L(v^(p^(i + n - j)))

    will be the one we want to invert; it is circulant, meaning each next line
    is equal to the previous one with a shift the right. The isomorphism 
    mentionned earlier is defined by taking the first line of the matrix and
    make it the coefficient of the element in the quotient ring. The
    coefficients will be :

    c_i = \sum_{0 <= j < n}{d_ij*L(z^(p^(n - j)))}.

    The function goes as follow :

    #. First, we need to compute the normal basis is it's not done already.

    #. Then, we compute the first line of the matrix we want to invert.

    #. We invert said matrix using the isomorphism mentionned earlier.

    #. We compute the vector containing the value of L(z^(p^(n-j))).

    #. Finally, we compute the coefficients as it was stated in the above
      formulas.

    REFERENCES :

    For more details, you can consult :
    https://github.com/brieulle/Rains-pinch/blob/master/latex/complexity.tex 
    '''
    n = v.parent().degree()
    p = v.parent().characteristic()
    R = PolynomialRing(GF(p), 'U')
    U = R.gen()

    if normal_basis is None:
        normal_basis = [v]
        for i in range(n-1):
            normal_basis.append(normal_basis[-1]**p)

    # We need only to compute Tr(v*v^(p^(n-i))) since the matrix is circulant.
    B = []
    for i in range(n):              
        B.append((v*normal_basis[-i]).trace())

    # We compute the inverse of the image of the circulant matrix B in the 
    # cyclotomic ring  GF(p^n)[U]/(U^n - 1) 
    inv = R(B).inverse_mod(U**n - 1)    
    
    val_trz = []   
    for i in range(n):
        val_trz.append((v*(z**p**(n-i))).trace())
    
    # We will now compute the coefficients c_i while keeping in mind that they 
    # are computed from each rows of the matrix B. So we need to take that into 
    # account and push the coefficient of inv "to the right". Practically, we 
    # just need to index them with (j-i)%n.
    c = []
    for i in range(n):                
        c.append(sum(inv[(j-i)%n]*val_trz[j] for j in range(n)))

    
    tuple(c)
    return c

def isom_normal(v,w, F, G, normal_basis_w = None, normal_basis_v = None):
    '''
    INPUT : 

    - ``v`` -- a normal element of a finite field F on GF(q).

    - ``w`` -- a normal element of a finite field G on GF(q).

    - ``F`` -- a finite field of q^n elements.

    - ``G`` -- a finite field of q^n elements.

    - ``normal_basis_w`` -- (default: None) a pre-calculated normal basis for w.

    - ``normal_basis_v`` -- (default: None) a pre-calculated normal basis for v.

    OUPUT : 

    - an element of G, the image of the generator of F by the isomorphism
      linking v to w.

    EXAMPLES : 

    sage: R.<X> = PolynomialRing(GF(101))

    sage: f = (X^19 + 85*X^18 + 87*X^17 + 18*X^16 + 40*X^15 + 48*X^14 + 3*X^13 +
    73*X^12 + 88*X^11 + X^10 + 76*X^9 + 81*X^8 + 83*X^7 + 8*X^6 + 96*X^5 +
    66*X^4 + 76*X^3 + 46*X^2 + 82*X + 47)

    sage: g = (X^19 + 91*X^18 + 89*X^16 + 94*X^15 + 78*X^14 + 83*X^13 + 62*X^12 
    + 5*X^11 + 3*X^10 + 84*X^9 + 34*X^8 + 88*X^7 + 40*X^6 + 100*X^5 + 58*X^4 +
    44*X^3 + 45*X^2 + 26*X + 60)

    sage: k1 = GF(101**19, name = 'x', modulus = f); x = k1.gen()

    sage: k2 = GF(101**19, name = 'y', modulus = g); y = k2.gen()

    sage: v = (49*x^18 + 6*x^17 + 66*x^16 + 86*x^15 + 35*x^14 + 82*x^13 + 
    16*x^12 + 55*x^11 + 73*x^10 + 86*x^9 + 48*x^8 + 28*x^7 + 93*x^6 + 51*x^5 + 
    46*x^4 + 19*x^3 + 68*x^2 + 75*x + 49)

    sage: w = (87*y^18 + 84*y^17 + 99*y^16 + 84*y^15 + 30*y^14 + 39*y^13 +
    96*y^12 + 62*y^11 + 71*y^9 + 44*y^8 + 40*y^7 + 9*y^6 + 45*y^5 + 21*y^4 +
    9*y^3 + 51*y^2 + 64*y + 47)

    sage: f(isom_normal(v, w, k1, k2))
    0

    ALGORITHM :

    The algorithm is pretty simple. We have v and w two normal elements such
    that there exists an isomorphisme phi with phi(v) = w. Then, we compute x in
    the normal basis generated by v and from that we deduce the image of x in
    function of the normal basis generated by w.

    .. NOTE::

    For our current applications, q = p.
    '''
    p = F.characteristic()
    n = F.degree()

    # We need to compute the normal basis generated by w.
    if normal_basis_w is None:
        normal_basis_w = [w]
        for i in range(n):
            normal_basis_w.append(normal_basis_w[-1]**p)

    # We begin by computing the coefficients of x in the normal basis
    # generated by v.
    normal_coefficients = convert(F.gen(), v, normal_basis_v)

    # Then we simply return its image in respect of the normal basis 
    # generated by w.
    return sum(normal_coefficients[i]*normal_basis_w[i]
                for i in range(n))


def calcul_isom_normal(elem, F, G, img_x):
    '''
    INPUT :

    - ``elem`` -- an element of a finite field F.

    - ``F`` -- a finite field of q^n elements.

    - ``G`` -- a finite field of q^n elements.

    - ``img_x`` -- the image of x by an isomorphism between F and G.

    OUTPUT :

    - an element of G, the image of elem by the isomorphism defined by img_x.

    EXAMPLES :
    sage: R.<X> = PolynomialRing(GF(101))

    sage: f = (X^19 + 85*X^18 + 87*X^17 + 18*X^16 + 40*X^15 + 48*X^14 + 3*X^13 +
    73*X^12 + 88*X^11 + X^10 + 76*X^9 + 81*X^8 + 83*X^7 + 8*X^6 + 96*X^5 +
    66*X^4 + 76*X^3 + 46*X^2 + 82*X + 47)

    sage: g = (X^19 + 91*X^18 + 89*X^16 + 94*X^15 + 78*X^14 + 83*X^13 + 62*X^12 
    + 5*X^11 + 3*X^10 + 84*X^9 + 34*X^8 + 88*X^7 + 40*X^6 + 100*X^5 + 58*X^4 +
    44*X^3 + 45*X^2 + 26*X + 60)

    sage: k1 = GF(101**19, name = 'x', modulus = f); x = k1.gen()

    sage: k2 = GF(101**19, name = 'y', modulus = g); y = k2.gen()

    sage: v = (49*x^18 + 6*x^17 + 66*x^16 + 86*x^15 + 35*x^14 + 82*x^13 + 
    16*x^12 + 55*x^11 + 73*x^10 + 86*x^9 + 48*x^8 + 28*x^7 + 93*x^6 + 51*x^5 + 
    46*x^4 + 19*x^3 + 68*x^2 + 75*x + 49)

    sage: w = (87*y^18 + 84*y^17 + 99*y^16 + 84*y^15 + 30*y^14 + 39*y^13 +
    96*y^12 + 62*y^11 + 71*y^9 + 44*y^8 + 40*y^7 + 9*y^6 + 45*y^5 + 21*y^4 +
    9*y^3 + 51*y^2 + 64*y + 47)

    sage: f(calcul_isom_normal(k1.gen(), k1, k2, isom_normal(v, w, k1, k2)))
    0

    sage: elem = k1.random_element()

    sage: elem.minpoly()(calcul_isom_normal(elem, k1, k2, isom_normal(v, w, k1, 
    k2)))
    0

    ALGORITHM :

    From img_x the image of x by an isomorphism between F and G, we simply
    compute the image of elem by this isomorphism.
    '''

    n = F.degree()

    elem_vector = elem.vector()

    puis_img = [1]

    for i in range(n):
            puis_img.append(puis_img[-1]*img_x)

    return sum([elem_vector[i]*puis_img[i] for i in range(n)])

