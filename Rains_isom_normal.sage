def isom_normal(v,w, F, G, base_normale_w = None, base_normale_v = None):
    '''
    Function that explicitly computes the isomorphism phi such as phi(v) = w.

    So we need that v and w are normal elements of F and G respectively and that
    there exists an isomorphism such as phi(v) = w.

    Concretely, we have the following :

    x = sum_i c_i*v^{p^i} => phi(x) = sum_i c_i*w^{p^i}

    we are computing phi(x).
    '''
    p = F.characteristic()
    n = F.degree()

    # We need to compute the normal basis generated by w.
    if base_normale_w is None:
        base_normale_w = [w]
        for i in range(n):
            base_normale_w.append(base_normale_w[-1]**p)

    # We begin by computing the coefficients of x in the normal basis
    # generated by v.
    temp_normal = convert(F.gen(), v, base_normale_v)[0] 

    # Then we simply return its image in respect of the normal basis 
    # generated by w.
    return sum(temp_normal[i]*base_normale_w[i]
                for i in range(n))

                

def convert(z, v, base_normale = None): 
    '''
    The goal of this function is to find the coefficients of an element z 
    of a finite field in the normal basis generated by the normal element v
    in the same finite field.
    '''
    n = v.parent().degree()
    p = v.parent().characteristic()
    R.<U> = PolynomialRing(GF(p)) 

    if base_normale is None:
        base_normale = [v]
        for i in range(n-1):
            base_normale.append(base_normale[-1]**p)

    # We need only to compute Tr(v*v^(p^(n-i))) since the matrix is circulant.
    B = []
    for i in range(n):              
        B.append((v*base_normale[-i]).trace())


    inv = R(B).inverse_mod(U**n - 1)    # We compute the inverse of the image of
                                        # the matrix B in the cyclotomic ring 
                                        # GF(p^n)[U]/(U^n - 1) 
    
    val_trz = []   
    for i in range(n):
        val_trz.append((v*(z**p**(n-i))).trace())
    
    # We will now compute the coefficients c_i while keeping in mind that they 
    # are computed from each rows of the matrix B. So we need to take that into 
    # account and push the coefficient of inv "to the right". Practically, we 
    # just need to index them with (j-i)%n.
    c = []
    for i in range(n):                
        c.append(sum(inv[(j-i)%n]*val_trz[j] for j in range(n)))

    
    tuple(c)
    return (c, base_normale, B, inv)

                
def calcul_isom_normal(elem, F, G, img_x):
    '''
    Function that given an element of F computes its image in G by the 
    isomorphism defined by the image of F.gen() named img_x.
    '''

    n = F.degree()

    elem_vector = elem.vector()

    puis_img = [1]

    for i in range(n):
            puis_img.append(puis_img[-1]*img_x)

    return sum([elem_vector[i]*puis_img[i] for i in range(n)])



